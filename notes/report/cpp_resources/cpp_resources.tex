%	This is written by Zhiyang Ong to document usage of C++ STL features that I can use for my C++ -based software, particularly those in electronic design automation.

%	The MIT License (MIT)

%	Copyright (c) <2014> <Zhiyang Ong>

%	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

%	The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

%	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

%	Email address: echo "cukj -wb- 23wU4X5M589 TROJANS cqkH wiuz2y 0f Mw Stanford" | awk '{ sub("23wU4X5M589","F.d_c_b. ") sub("Stanford","d0mA1n"); print $5, $2, $8; for (i=1; i<=1; i++) print "6\b"; print $9, $7, $6 }' | sed y/kqcbuHwM62z/gnotrzadqmC/ | tr 'q' ' ' | tr -d [:cntrl:] | tr -d 'ir' | tr y "\n"

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{C++ Resources}
\label{chp:CppResources}

Quick advice: {\tt Learn how to use {\it C++1y} features, including those of {C++11}, {C++14}, and {C++17}.} Older {\it C++} versions include {\it C++98} and {\it C++03}. \\

Reference: Free Software Foundation contributors, ``{C++1y/C++14} Support in {GCC},'' from {\it {GCC}, the {GNU} Compiler Collection: {GCC} Projects}, Free Software Foundation, Boston, MA, November 14, 2015. Available online at: \url{https://gcc.gnu.org/projects/cxx1y.html}; last accessed on January 25, 2016.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Resources for C++ and Notes About C++}
\label{sec:ResourcesAndNotesAboutCpp}

Some {C++} and C++ STL resources are: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item \cite{Mohtashim2015a}: \url{http://www.tutorialspoint.com/cplusplus/cpp_stl_tutorial.htm}
\item \cite{CplusplusCom2014,CplusplusCom2015,CplusplusCom2015a,CplusplusCom2015b,Soulie2007}: \url{http://www.cplusplus.com/reference/stl/}
%	\item \cite{CplusplusCom2014}, \cite{CplusplusCom2015}, \cite{CplusplusCom2015a}, \cite{CplusplusCom2015b}, and \cite{Soulie2007}: \url{http://www.cplusplus.com/reference/stl/}
\item \cite{cppreference2015}: \url{http://en.cppreference.com/w/cpp/container}
\item \url{http://www.cs.wustl.edu/~schmidt/PDF/stl4.pdf}
\item Pointers to functions \cite{CplusplusCom2015b}: \url{http://www.cplusplus.com/doc/tutorial/pointers/}
\end{enumerate}


C++ topics: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item Function objects: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \url{https://en.wikipedia.org/wiki/Functional_(C%2B%2B)}
	\item \url{http://stackoverflow.com/questions/356950/c-functors-and-their-uses}
	\item \url{http://www.cprogramming.com/tutorial/functors-function-objects-in-c++.html}
	\end{enumerate}
\item Strings: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Stroustrup2014}, Chp 23
	\item \cite{Stroustrup2009}, Chp 23
	\item \cite{Gregoire2014}, Chp 18
	\item \cite{Allain2012}, Chp 19
	\item \cite{Eckel2003}, Chp 1
	\item \cite{McMahon20XY}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item C strings (or C-strings, or C-style strings) are null-terminated strings (arrays of characters that each end with a terminating ``null character'' with ASCII value 0) and are arrays of characters; the ``null character'' is usually represented by the literal character '$\backslash$0'. ``However, an array of {\tt char} is NOT by itself a C string.''
		\item ``Since {\tt char} is a built-in data type, no header file is required to create a C string. The C library header file $<${\tt cstring}$>$ contains a number of utility functions that operate on C strings.''
		\item ``It is also possible to declare a C string as a pointer to a {\tt char}: char$^{\ast}$ s3 = ``hello''; '' It creates a character array with just enough memory space (in the heap) to store the null-terminated string. The address of the string's first character is placed in the {\tt char} pointer {\it s3}. When this improperly used, it can corrupt program memory or cause run-time errors.
		\item ``[Use] the {\tt C} library function {\tt strlen()}'' to determine ``the length of a {\tt C} string.'' It returns an unsigned integer representing the number of characters in the string, excluding the terminating null character.
		\item Relational operators (such as $==, !=, >, <, >=, <=$) compare the addresses of the first characters in the two string operands (as the array names are treated as pointers), instead of the contents of these strings.
		\item ``Use the {\tt C} library function {\tt strcmp()}'' ``to compare the contents of two {\tt C} strings.'' The input arguments of this function are two pointers to {\tt C} strings.
		\item ``Use the {\tt C} library function {\tt strcpy()}'' to assign a string to a C string or change its contents. The {\tt strcpy()} function accepts a pointer to the C string as the first input argument, and a pointer to the contents of a valid C string or string literal (i.e., a character) as the second input argument. The {\tt C} library function {\tt strcat()} has the same input arguments as {\tt strcpy()}, and is used for concatenating two strings.
		\item C strings can be used as input parameters or the return type. They are specified as {\tt char[]} or {\tt char$^{\ast}$}.
		\item ``A {\tt C++} string is an object of the class string, which is defined in the header file $<$string$>$ and which is in the standard namespace.'' The variable name of a {\tt C++} string is a pointer to the first character of the string; the variable name contains the address of the string's first character. The {\tt C++} string is a dynamically-allocated array of characters.
		\item ``[Use] the string class methods {\tt length()} or {\tt size()}'' to determine ``the length of the {\tt C++} strings.''
		\item To improve memory efficiency and reduce memory usage, explicitly {\it pass a string object}. Else, the {\tt C++} string objects are pass and returned by value, which involves making a copy of the string object.
		\item Concatenate C++ strings, C strings, and string literals in any order using the ``+'' operator.
		\item Convert a C++ string into a C string via the {\tt c\_str()} function of the {\tt string} class. The {\tt c\_str()} function returns a pointer to the array of characters representing the string. If the C++ string is not null-terminated, a null character is appended to the new C string. The returned C string ``can be used, printed, copied, etc.'' but not be modified.
		\item Since programming with arrays can enbug the code more easily, the use of C++ {string} is (strongly) recommended for use. This is because the properties of a2
		\item When a C string is required by a function, convert the C++ string into a C string (as aforementioned). Instances in which a C string have to be converted into a C++ string are: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item Strings passed into {\tt main()} as C strings from the command line argument.
			\item Functions for file input/output operations require filenames to be specified as C strings.
			\item The C++ string class does not have the equivalent functions of certain C string library functions.
			\item Unlike C++ strings, C strings can be serialized in binary format without requiring a bunch of extra code to be written.
			\end{enumerate}
		\item The function {\tt atoi} converts a string to an integer. Similar functions for converting strings into numbers are: {\tt atol} and {\tt atof}. The C++ STL does not have a {\tt itoa} function to convert a number to an integer. However, some compilers supports this function in the {\it C Standard General Utilities Library}.
		\end{enumerate}
	\item \cite{Heller2003}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item The {\tt put} pointer points ``to the next free byte in the {\tt stringstream}.'' That is, it ``holds the address of the next byte in the output area of the'' {\tt stringstream}. When the {\tt stringstream} is empty, the {\tt put} pointer points to the beginning of the {\tt stringstream} buffer. \cite[\S9.8]{Heller2003}.
		\item ``The type of the {\tt put} pointer'' does not matter to the software developer(s), since they ``cannot access it directly'' \cite[\S9.8]{Heller2003}.
		\item ``The {\tt get} pointer holds the address of the next byte in the input area of the stream, or the next byte we get if we use $>>$ to read data from the {\tt stringstream}'' \cite[\S9.9]{Heller2003}.
		\item ``The {\tt end} pointer indicates the end of the {\tt stringstream}. Attempting to read anything at or after this position will cause the read to fail because there is nothing else to read'' \cite[\S9.9]{Heller2003}.
		\item Developers only have to know about how {\tt put}, {\tt get}, and {\tt end} pointers work. They do not have to know the actual representation of these pointers \cite[\S9.9]{Heller2003}.
		\item The {\tt stringstream} object acts as a buffer, and is ``an area of allocated memory'' (``by the stringstream member functions'') \cite[\S9.9]{Heller2003}.
		\end{enumerate}
	\item The function {\tt strtol} converts a string into a long integer: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item See \url{http://www.cplusplus.com/reference/cstdlib/strtol/}.
		\item \cite[$<$cstdlib$>$ (stdlib.h) -- C Standard General Utilities Library: {\tt strtol} function]{CplusplusCom2015}
		\end{enumerate}
	\item Danny Kalev, ``String Streams,'' in {\it {InformIT}: The Trusted Technology Learning Source: Articles: Programming: {C/C++} Articles: {InformIT C++} Reference Guide}, Pearson Education, Indianapolis, IN, January 1, 2003. Available online at: \url{http://www.informit.com/guides/content.aspx?g=cplusplus&seqNum=72}; last accessed on November 13, 2015. \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item Static buffers (via {\it atoi()}, {\it sprintf()}, or {\it sscanf()} from the {\it $<$stdio.h$>$}) for type conversions can cause buffer overflow and do not provide adequate type safety (i.e., adequate type checking mechanism). This can be mitigated via {\it stringstreams}.
		\end{enumerate}
	\end{enumerate}
\item IO Streams: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Eckel2003}, Chp 2
	\item \cite{Gaddis2010}, Chp 12. See all of \cite{Gaddis2010,Gaddis2011,Gaddis2012}.
	\item \cite{Stroustrup2014}, Chp 10-11
	\item \cite{Stroustrup2009}, Chp 10-11
	\item \cite{Oualline2003}, Chp 16
	\item \cite{Vermeir2001}, Chp 10
	\item \cite{Schildt2003}, Chp 21
	\item \cite{Allain2012}, Chp 28
	\item \cite{Gregoire2014}, Chp 12
	\item \cite{Prata2012}, Chp 17
	\item \cite{Lippman2013}, Chp 8
	\end{enumerate}
\item Templates: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Eckel2003}, Chp 3
	\item \cite{Eckel2000}, Chp 16
	\item \cite{Stroustrup2014}, Chp 19
	\item \cite{Stroustrup2009}, Chp 19
	\item \cite{Oualline2003}, Chp 24
	\item \cite{Vermeir2001}, Chp 6
	\item \cite{Alexandrescu2001}, book; typelist - Chp 3
	\item \cite{Schildt2003}, Chp 18
	\item \cite{Vandevoorde2003}, book
	\item \cite{Abrahams2005}, book
	\item \cite{Allain2012}, Chp 29
	\item \cite{Gregoire2014}, Chp 11,21
	\item \cite{Lippman2013}, Chp 16
	\end{enumerate}
\item Debugging: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Eckel2003}, Chp 11 (especially memory management problems, pp. 533)
	\end{enumerate}
\item STL containers: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Eckel2003}, Chp 4
	\item \cite{Schildt2004a}, Chp 8
	\item \cite{Oualline2003}, Chp 25
	\item \cite{Vermeir2001}, Chp 7
	\item \cite{Reese2006a}, book
	\item \cite{Allain2012}, Chp 18
	\item \cite{Gregoire2014}, Chp 15-16
	\item \cite{Prata2012}, Chp 16
	\item \cite{Lippman2013}, Chp 9,11
	\item \cite{EliteHussar2010}: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item {\tt vector$<$int$>$ v(10);} \hspace{0.2in} //{\it\ Create an int vector of size 10.}
		\item {\tt v[5] = 10;} //{\it\ Target of this assignment is the return value of operator[].}
		\end{enumerate}
	\end{enumerate}
\item STL algorithms: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Eckel2003}, Chp 5
	\item \cite{Oualline2003}, Chp 25
	\item \cite{Vermeir2001}, Chp 7
	\item \cite{Reese2006a}, book
	\item \cite{Allain2012}, Chp 18
	\item \cite{Gregoire2014}, Chp 15,17
	\item \cite{Prata2012}, Chp 16
	\item \cite{Lippman2013}, Chp 10
	\end{enumerate}
\item Function addresses: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Eckel2000}, Chp 3, pp. 213
	\item \cite{Stroustrup2014}, Chp 8
	\item \cite{Stroustrup2009}, Chp 8
	\end{enumerate}
\item Dynamic memory management problems: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Eckel2000}, Chp 6,13
	\item \cite{Gaddis2010}, Chp 13. See all of \cite{Gaddis2010,Gaddis2011,Gaddis2012}.
	\item \cite{Meyers2005}, Chp 2-4
	\item \cite{Schildt2003}, Chp 29
	\item \cite{Allain2012}, Chp 14
	\item \cite{Gregoire2014}, Chp 10,22
	\item \cite{Prata2012}, Chp 9,12
	\item \cite{Lippman2013}, Chp 12,13
	\end{enumerate}
\item Function overloading: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Eckel2000}, Chp 7
	\item \cite{Gaddis2010}, Chp 6. See all of \cite{Gaddis2010,Gaddis2011,Gaddis2012}.
	\item \cite{Stroustrup2014}, Chp 8
	\item \cite{Stroustrup2009}, Chp 8
	\item \cite{Schildt2003}, Chp 14
	\end{enumerate}
\item Operator overloading: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Eckel2000}, Chp 12
	\item \cite{Oualline2003}, Chp 18
	\item \cite{Schildt2003}, Chp 15
	\item \cite{Lippman2013}, Chp 14
	\end{enumerate}
\item Constants: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Eckel2000}, Chp 8
	\end{enumerate}
\item Functions and pointers: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Eckel2000}, Chp 11: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item use const at the end of accessor functions
		\item Do not use pointers as instance variables
		\end{enumerate}
	\item \cite{Stroustrup2014}, Chp 8: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item Pass-by-reference: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item e.g., void init(vector$<$double$>$ \&v)
			\item ``It is not possible to refer directly to a reference variable after it is defined; any occurrence of its name refers directly to the variable it references. ''
			\item ``Once a reference is created, it cannot be later made to reference another variable. This is something that is often done with pointers.''
			\item ``References cannot be null, whereas pointers can; every reference refers to some variable, although it may or may not be valid.''
			\item ``References cannot be uninitialized. Because it is impossible to reinitialize a reference, they must be initialized as soon as they are created. In particular, local and global variables must be initialized where they are defined, and references which are data members of a class must be initialized in the initializer list of the class's constructor.''
			\item Avoid mixing references and pointers in a block of code to avoid confusion, and make it easier for the {\it C++} code to be read and debug.
			\item The required syntax for pointers make them prominent in comparison to that of references.
			\item The number of operations on references is less than that on pointers. Hence, usage of references is easier to understand than that of pointers. Consequently, it is easier to use references than pointers without enbugging the code.
			\item Pointers can be invalidated as follows: \vspace{-0.1cm}
				\begin{itemize} \itemsep -1pt
				\item ``Carrying a null value''
				\item ``Out-of-bounds [pointer] arithmetic''
				\item Illegal casts on pointers
				\item Produce pointers from random integers
				\end{itemize}
			\item References can be invalidated as follows: \vspace{-0.1cm}
				\begin{itemize} \itemsep -1pt
				\item ``[Refer] to a variable with automatic allocation which goes out of scope''
				\item ``[Refer] to an object inside a block of dynamic memory which has been freed''
				\end{itemize}
			\item ``Arrays are always passed by address. This includes C strings.''
			\item ``Dynamic storage is allocated using pointers.''
			\item Reference: Kurt McMahon, ``Passing Variables by Address,'' in {\it Northern Illinois University: College of Engineering and Engineering Technology: Department of Computer Science: CSCI 241 Intermediate Programming in C++ (Fall 2015): Notes}, Northern Illinois University, DeKalb, IL, October 28, 2015. Available online at: \url{http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/pass_by_address.html}; last accessed on November 3, 2015.
			\end{enumerate}
		\item Pass-by-const-reference: e.g., void print(const vector$<$double$>$ \&v)
		\item Pass-by-value: e.g., void fn(int x)
		\item Pass-by-address: e.g., void print(int * ptr) \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item Reference: Kurt McMahon, ``Passing Variables by Address,'' in {\it Northern Illinois University: College of Engineering and Engineering Technology: Department of Computer Science: CSCI 241 Intermediate Programming in C++ (Fall 2015): Notes}, Northern Illinois University, DeKalb, IL, October 28, 2015. Available online at: \url{http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/pass_by_address.html}; last accessed on November 3, 2015.
			\end{enumerate}
		\end{enumerate}
	\item \cite{Stroustrup2009}, Chp 8
	\item \cite{Oualline2003}, Chp 15,20
	\item \cite{Allain2012}, Chp 12-13
	\item \cite{Prata2012}, Chp 7-8
	\item \cite{Lippman2013}, Chp 6
	\item Elsewhere: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item You cannot call a non-const method from a const method. That would 'discard' the const qualifier.: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item \url{http://stackoverflow.com/questions/2382834/discards-qualifiers-error}
			\end{enumerate}
		\item Pointer to constant data: {\it const type$^{\ast}$ variable;} and {\it type const $^{\ast}$ variable;} \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item \url{http://www.cprogramming.com/reference/pointers/const_pointers.html}
			\end{enumerate}
		\item Pointer with constant memory address: {\it type $^{\ast}$ const variable = some-memory-address;} \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item \url{http://www.cprogramming.com/reference/pointers/const_pointers.html}
			\end{enumerate}
		\item Constant data with a constant pointer: {\it const type $^{\ast}$ const variable = some-memory-address;} and {\it type const $^{\ast}$ const variable = some-memory-address;} \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item \url{http://www.cprogramming.com/reference/pointers/const_pointers.html}
			\end{enumerate}
		\item \url{http://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const} \cite{Mortensen2015}: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item Read it backwards; the first {\it const} can be on either side of the type.
			\item ``Read pointer declarations right-to-left.''
			\item From the answer of Ted Dennison, July 17, 2009. {\bf Rule: The ``const'' goes after the thing it applies to. Putting const at the very front (e.g., const int $^{\ast}$) is an exception to the rule.}
			\item int$^{\ast}$ -- pointer to int
			\item int const $^{\ast}$ == const int $^{\ast}$ -- pointer to const int
			\item int $^{\ast}$ const -- const pointer to int
			\item int const $^{\ast}$ const == const int $^{\ast}$ const -- const pointer to const int
			\item int $^{\ast}$$^{\ast}$ -- pointer to pointer to int
			\item int $^{\ast}$$^{\ast}$ const -- A const pointer to a pointer to an int
			\item int $^{\ast}$ const $^{\ast}$ -- A pointer to a const pointer to an int
			\item int const $^{\ast}$$^{\ast}$ -- A pointer to a pointer to a const int
			\item int $^{\ast}$ const $^{\ast}$ const -- A const pointer to a const pointer to an int
			\end{enumerate}
		\item For the following \cite{Mortensen2015}, let: {\it int var0 = 0;} \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item {\it const int {\rm \&}ptr1 = var0;} // Constant reference
			\item {\it int $^{\ast}$ const ptr2 = {\rm \&}var0;} // Constant pointer
			\item {\it int const $^{\ast}$ ptr3 = {\rm \&}var0;} // Pointer to const
			\item {\it const int $^{\ast}$ const ptr4 = {\rm \&}var0;} // Const pointer to a const
			\end{enumerate}
		\item A pointer is dereferenced via the explicit $^{\ast}$ operator. The $^{\ast}$ operator should not be used to dereference a reference (variable) \cite{Saks2001}.
		\item \cite{Saks2001}: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item int $^{\ast}$pi = {\&}i; // Indirect expression to dereference $pi$ to $i$. ``Declare $pi$ as an object of type `pointer to int' whose initial value is the address of object $i$'' \cite{Saks2001a}.
			\item int {\&}ri = i; // $ri$ is dereferenced to refer to $i$. ``Declares $ri$ as an object of type `reference to int' referring to $i$'' \cite{Saks2001a}.
			\item The {\it C++} standard does not dictate how compilers shall implement references. However, popular compilers tend to implement references as pointers. Therefore, there are no significant advantages of using references or pointers.
			\end{enumerate}
		\item \cite{Saks2001a}: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item ``A valid reference must refer to an object; a pointer need not. A pointer, even a const pointer, can have a null value. A null pointer doesn't point to anything.''
			\item I can bind a reference to a null pointer, but I cannot dereference a null pointer since it can ``produce undefined behavior''.
			\end{enumerate}
		\item \cite{Ozcan2013}: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item ``A reference is a variable that refers to something else and can be used as an alias for that something else. A pointer is a variable that stores a memory address, for the purpose of acting as an alias to what is stored at that address. So, a pointer is a reference, but a reference is not necessarily a pointer. Pointers are a particular implementation of the concept of a reference, and the term tends to be used only for languages that give you direct access to the memory address. References can be implemented internally in a language using pointers, or using some other mechanism.'' Answer from dan1111.
			\item ``Passing an object by value means making a copy of it. You can modify that copy without affecting the original. Making that copy can cost a lot of memory access though. Passing an object by reference means passing a handle to that object. This is cheaper because you don't need to make a copy. It also means that any changes you make will affect the original.'' Answer from Steve Rowe.
			\item ``There is no such thing as a null reference. A reference must always refer to some object. As a result, if you have a variable whose purpose is to refer to another object, but it is possible that there might not be an object to refer to, you should make the variable a pointer, because then you can set it to null. On the other hand, if the variable must always refer to an object, i.e., if your design does not allow for the possibility that the variable is null, you should probably make the variable a reference.'' Answer from Harssh S. Shrivastava.
			\end{enumerate}
		\end{enumerate}
	\item With shallow copying, I would only copy the memory references or pointers. The copy and the original reference the same object. On the other hand, with deep copying, I would copy the values; this is also known as cloning. The copy and the original reference do not share objects; each of them references its own object. The default copy constructor carries out shallow copy.
	\end{enumerate}
\item OOD and inheritance: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Eckel2000}, Chp 14,15
	\item \cite{Gaddis2010}, Chp 13,14,15. See all of \cite{Gaddis2010,Gaddis2011,Gaddis2012}.
	\item \cite{Stroustrup2014}, Chp 9
	\item \cite{Stroustrup2009}, Chp 9
	\item \cite{Oualline2003}, Chp 13-14,21
	\item \cite{Vermeir2001}, Chp 3-4,8
	\item \cite{Allain2012}, Chp 24-26
	\item \cite{Gregoire2014}, Chp 4-9
	\item \cite{Prata2012}, Chp 10-11,13,14,15
	\item \cite{Lippman2013}, Chp 7,15,18,19
	\end{enumerate}
\item SW engineering issues: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Allain2012}, Chp 21
	\item \cite{Gregoire2014}, Chp 24-26
	\end{enumerate}
\item multi-threading: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Schildt2004a}, Chp 3
	\end{enumerate}
\item graphs: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item \cite{Schildt2004a}, Chp 7
	\end{enumerate}
\item typedef: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item In the sandbox, use the {\it Make} target {\it make typedef} to study an example of how {\it typedef} can be used. When the {\it header file} defines/specifies the {\it typedef}, and is included in the {\it C++ implementation file} and other {\it C++ implementation file}s that instantiates those objects, it can be used subsequently without additional definition/specification. October 6, 2015.
	\end{enumerate}
\end{enumerate}


Books to classify: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item C++ programming: \cite{Horstmann2012,Katupitiya2006,Koenig2000,Pozrikidis2007,Prata2005,Romanik2003,Savitch2009,Scheinerman2006,Schildt1998a,Schildt2003a}
\item C++ STL: \cite{Josuttis2012,Karlsson2006a,Robson2000,HewlettPackardCompanyStaff2014,HewlettPackardCompanyStaff1994,Riesbeck2009,Cline2000,Cline2003,Cline2011}
\item C++ -based MPI programming: \cite{Karniadakis2003}
\item scientific computing: \cite{PittFrancis2012}
\item Boost C++: \cite{Mukherjee2015,Polukhin2013,Schaling2012}
\end{enumerate}










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Computational Complexity of C++ Containers}
\label{sec:ComputationalComplexityofCppContainers}


Table \ref{tab:ComputationalComplexityofCppContainers} shows a tabulated summary of containers in the {\it C++} Standard Template Library (STL) and the computational complexity for each of their common operations: add(element e), remove(element e), search(element e), size(), empty(), begin(), and end(). \\

%\begin{table}[htdp]
\begin{table}[htp]
\caption{Computational Complexity of Basic Operations of Containers from the {\it C++ STL}.}	\vspace{-0.2in}
\label{tab:ComputationalComplexityofCppContainers}
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|c|c|}
		\hline
		Container $\backslash$ Complexity & add & remove & search & size & empty & begin & end \\
		\hline
		vector & O(1) & O(n) & O(n) & O(1) & O(1) & O(1) & O(1) \\
		\hline
		list & O(1) & O(n) & O(n) & O(1) & O(1) & O(1) & O(1) \\
		\hline
		queue & O(1) amortized & O(1) & O(n) & O(1) & O(1) & O(1) & O(1) \\
		\hline
		priority queue & O(log n) & O(log n) & O(n) & O(1) & O(1) & O(1) & ??? \\
		\hline
		set & O(log n) & O(log n) & O(log n) & O(1) & O(1) & O(1) & O(1) \\
		\hline
		multi-set & O(log n) & ??? & O(log n) & O(1) & O(1) & O(1) & O(1) \\
		\hline
		map & O(log n) & O(log n) & O(log n) & O(1) & O(1) & O(1) & O(1) \\
		\hline
		multi-map & O(log n) & ??? & O(log n) & O(1) & O(1) & O(1) & O(1) \\
		\hline
		stack & O(1) & O(1) & O(n) & O(1) & O(1) & O(1) & O(1) \\
		\hline
		\end{tabular}
	\end{center}
\end{table}


To conclude, we can get some facts about each data structure: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item {\tt std::list} is very very slow to iterate through the collection due to its very poor spatial locality.
\item {\tt std::vector} and {\tt std::deque} perform always faster than {\tt std::list} with very small data
\item {\tt std::list} handles very well large elements
\item {\tt std::deque} performs better than a {\tt std::vector} for inserting at random positions (especially at the front, which is constant time)
\item {\tt std::deque} and {\tt std::vector} do not support very well data types with high cost of copy/assignment
\end{enumerate}



This draws simple conclusions on the usage of each data structure \cite{Bulka2000,Josuttis1999a}: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item Number crunching: use std::vector or std::deque
\item Linear search: use std::vector or std::deque
\item Random Insert/Remove:
\item Small data size: use std::vector
\item Large element size: use std::list (unless if intended principally for searching)
\item Non-trivial data type: use std::list unless you need the container especially for searching. But for multiple modifications of the container, it will be very slow.
\item Push to front: use std::deque or std::list
\end{enumerate}

Notes about asymptotic notations: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item Comparison of big O notations, and other asymptotic notations, in general -- based on ``running time (T(n))'' $[$Wikipedia 2015a$] [$Wikipedia 2015$]$: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item $O(1)$: constant time
	\item $O(\log^{\ast} n)$, log star: iterated logarithmic time.

	Log star n is a recursive function; $\log^{\ast} n \coloneqq
		\begin{cases}
		0 &: \mathrm{if}\ n \leq 1 \\
		1 + \log^{\ast}(\log n) &: \mathrm{if}\ n > 1 \\
		\end{cases}$\ $[$Wikipedia 2015b$]$
%	\usepackage{mathtools}
%	Use the above/aforementioned package to use the symbol: \coloneqq \cite{Pakin2008}
	\item $O(\log \log n)$: log-logarithmic, double logarithmic
	\item $O(\log n)$: logarithmic time, computational time complexity class DLOGTIME. E.g., $\log n^{2}$.
	\item poly$(\log n)$ or $O((\log n)^{c}), c > 1$: polylogarithmic time. E.g., $(\log n)^{2}$.
	\item $O(n^{c})$, where $0 < c < 1$: fractional power. E.g., $n^{\frac{2}{3}}$.
	\item $o(n)$: sub-linear time (or sublinear time)
	\item $O(n)$: linear time
	\item $O(n \log^{\ast} n)$: ``n log star n'' time, or ``n log-star n''
	\item $O(n \log n) = O(\log n!)$: linearithmic time, including $\log n!$. Or, loglinear, or quasilinear.
	\item $O(n^{2})$: quadratic time
	\item $O(n^{3})$: cubic time
	\item poly$(n)$, or $2^{O(\log n)}$. Or, $O(n^{c}), c > 1$: polynomial time, including $n, n \log n, n^{10}$. Computational time complexity class P. Or, algebraic.
	\item $2^{{\rm poly}(\log n)}$: quasi-polynomial time, including $n^{\log \log n}, n^{\log n}$. Computational time complexity class QP.
	\item $O(2^{n^{\varepsilon}}), \forall \varepsilon > 0$: sub-exponential time, including $O(2^{\log n^{\log \log n}})$. Computational time complexity class SUBEXP.
	\item $2^{o(n)}$: sub-exponential time, including $2^{n^{\frac{1}{3}}}$. Computational time complexity class SUBEXP. Or, L-notation.
	\item $2^{O(n)}$: exponential time (with linear exponent), including $1.1^{n}, 10^{n}$. Computational time complexity class E.
	\item $2^{{\rm poly}(n)}$. Or, $O(c^{n}), c > 1$: exponential time, including $2^{n}, 2^{n^{2}}$. Computational time complexity class EXPTIME.
	\item $O(n!)$: factorial time, including $n!$.
	\item $2^{2^{{\rm poly}(n)}}$: double exponential time, including $2^{2^{n}}$. Computational time complexity class 2-EXPTIME.
	\item $n! > n^{n}$
	\end{enumerate}
\item Types of asymptotic notations $[$Wikipedia 2015$]$: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item $f(n) = O(g(n))$: Big O notation, or Big Oh notation
	\item $f(n) = \Omega(g(n))$: Big Omega notation
	\item $f(n) = \Theta(g(n))$: Big Theta notation
	\item $f(n) = o(g(n))$: Small O notation, or Small Oh notation
	\item $f(n) = \omega(g(n))$: Small Omega notation
	\item $f(n) \sim g(n)$: ``On the order of''
	\end{enumerate}
\item References: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item $[$Wikipedia 2015$]$ Wikipedia contributors, ``Big O notation,'' sections {\it Orders of common functions} and {\it Related asymptotic notations: Family of Bachmann?Landau notations}, in {\it Wikipedia, The Free Encyclopedia: Analysis of algorithms, or Asymptotic analysis}, Wikimedia Foundation, San Francisco, CA, November 29, 2015. Available online at: \url{https://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions}; last accessed on December 1, 2015.
	\item $[$Wikipedia 2015a$]$ Wikipedia contributors, ``Time complexity,'' section {\it Table of common time complexities}, in {\it Wikipedia, The Free Encyclopedia: Computational complexity theory}, Wikimedia Foundation, San Francisco, CA, November 16, 2015. Available online at: \url{https://en.wikipedia.org/wiki/Time_complexity#Table_of_common_time_complexities}; last accessed on December 1, 2015.
	\item $[$Wikipedia 2015b$]$ Wikipedia contributors, ``Iterated logarithm,'' in {\it Wikipedia, The Free Encyclopedia: Asymptotic analysis}, Wikimedia Foundation, San Francisco, CA, November 6, 2015. Available online at: \url{https://en.wikipedia.org/wiki/Iterated_logarithm}; last accessed on December 1, 2015.
	\end{enumerate}
\item Note that I denote ``is defined as'' as: $\equiv, \triangleq, \stackrel{\text{\tiny def}}{=}, \coloneqq$
\item Note that $\log n$ is faster than $(\log n)^{2}$, although initially the latter is slightly faster than the former (for negligibly small $n$).
\end{enumerate}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Additional Notes About C++}
\label{sec:AdditionalNotesAboutCpp}


Static variables: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	\item K. Hong, ``C++ Tutorial
%	Private Inheritance - 2015,'' San Francisco, CA. Available online from {\it Open Source \dots: Java/C++/Python/Android/Design Patterns: C++ Tutorial Home -- 2015} at: \url{}; last accessed on October 23, 2015.
\item K. Hong, ``Static Variables and Static Class Members - 2015,'' San Francisco, CA. Available online from {\it Open Source \dots: Java/C++/Python/Android/Design Patterns: C++ Tutorial Home -- 2015} at: \url{http://www.bogotobogo.com/cplusplus/statics.php}; last accessed on October 23, 2015.
\end{enumerate}




Formatting data: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item Synesis Software Pty Ltd staff, ``Synesis Software Training Courses: FastFormat, Beginner's (part 1 of 2),'' Synesis Software Pty Ltd, Sydney, Australia, 2015.  Available online at: \url{http://www.synesis.com.au/training-beginners-fastformat.html}; December 1, 2015 was the last accessed date. \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item ``Formatting APIs'': \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item ``Replacement-based APIs'': \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item ``Streams (printf()-family)''
			\item ``Boost.Format''
			\item ``FastFormat.Format''
			\end{enumerate}
		\item ``Concatenation-based APIs'': \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item ``IOStreams''
			\item ``Loki.SafeFormat''
			\item ``FastFormat.Write''
			\end{enumerate}
		\end{enumerate}
	\item ``struct tm''
	\item ``struct in\_addr''	% struct in_addr
	\item ``ATL types''
	\item ``ACE types''
	\end{enumerate}
\item Synesis Software Pty Ltd staff, ``Synesis Software Training Courses: FastFormat, Advanced (part 2 of 2),'' Synesis Software Pty Ltd, Sydney, Australia, 2015.  Available online at: \url{http://www.synesis.com.au/training-advanced-fastformat.html}; December 1, 2015 was the last accessed date. \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item ``Format-specification Defect Handling'': ``Scoping'' and ``Disgnostic Logging''
	\end{enumerate}
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Alternate Computer Number System for Representing Fractions in C++}
\label{ssec:AlternateComputerNumberSystemforRepresentingFractionsInCpp}

An alternate computer number system for representing fractions in C++ is the fixed-point number system. For a detailed classification of computer number systems, see \cite{Lu2004}. \\

In {\it C++}, the numerical data types are based on cardinal numbers (e.g., one, two, three, \dots), instead of ordinal numbers/integers (e.g., first, second, third, \dots); see \cite{DictionaryDotComStaff2016} for the definitions of ``cardinal number'' and ``ordinal number.''









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Software Development in C++}
\label{sec:SoftwareDevelopmentInCpp}


Notes about software development in {\it C++}: \vspace{-0.3cm}
\begin{enumerate} \itemsep -4pt
\item Notes from Synesis Software Pty Ltd: \vspace{-0.3cm}
	\begin{enumerate} \itemsep -2pt
	\item Synesis Software Pty Ltd staff, ``Synesis Software Training Courses,'' Synesis Software Pty Ltd, Sydney, Australia, 2015.  Available online at: \url{http://www.synesis.com.au/training.html}; December 1, 2015 was the last accessed date. \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item Use {\tt FastFormat} as a ``C++ diagnostic logging API library''
		\item {\tt STLSoft libraries}. ``Apply the concepts, principles and techniques of Extended STL to enhance the expressiveness, flexibility, and performance of your C++ software.'' See \cite{Wilson2007} for more details.
		\item ``Building Bullet-Proof Software in C++ - no system built by Synesis Software has ever failed in production. This course takes you through the principles and practices of how we develop software, providing you with practical, applicable strategies and tactics for achieving the same outcome in your software developments.''
		\item ``Guerilla Testing C++ - or, {\bf \large `How to discover the Gold Nuggets in your Big Ball of Mud'}. No matter how badly a C++ codebase is enmeshed, you can get it under test if you know how to master its coupling.''
		\end{enumerate}
	\item Synesis Software Pty Ltd staff, ``Resources,'' Synesis Software Pty Ltd, Sydney, Australia.  Available online at: \url{http://www.synesis.com.au/resources.html}; December 1, 2015 was the last accessed date. \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item 100\% type-safe {\it C++} API
		\item C++ diagnostic logging API library (or, diagnostic logging libraries): \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item Pantheios: \url{http://pantheios.org/}
			\item ACE
			\item log4cxx
			\end{enumerate}
		\item C++ formatting library: FastFormat \url{http://fastformat.org/}
		\item ``The STLSoft libraries provide STL extensions and facades over operating-system and third-party-library APIs. The libraries are 100\% header-only.'' See \url{http://stlsoft.org/}.
		\item ``UNIXem is a simple library that emulates a useful subset of the UNIX system APIs on Windows\dots\ UNIXem is the only library provided by Synesis Software that is not production-quality. It is appropriate for research, such as when developing tests for cross-platform software.'' See \url{http://synesis.com.au/software/unixem.html}.
		\end{enumerate}
	\item Synesis Software Pty Ltd staff, ``Guerilla Testing C++ or, `How to discover the Gold Nuggets in your Big Ball of Mud','' Synesis Software Pty Ltd, Sydney, Australia.  Available online at: \url{http://www.synesis.com.au/training-guerilla-testing-cplusplus.html}; December 1, 2015 was the last accessed date.: \vspace{-0.2cm}
		\begin{enumerate} \itemsep -2pt
		\item ``Change is the most expensive part of the cost of a software project. The biggest impediments to change are lack of clarity on what to alter to effect the change, and uncertainty about unintended side-effects of the change.''
		\item ``No matter how badly a C++ codebase is enmeshed, you can get it under test if you know how to master its coupling.''
		\item ``Many long-lived codebases have evolved to a point where some, perhaps most, aspects of its functionality are no longer precisely known / codified / automatically tested. This course will teach you, using practical examples, how to wrest control from any codebase, no matter how badly enmeshed, isolate known pieces of good functionality, get them under test, and eventually to isolate and separate them into a new context, while, where required, maintaining compatibility with their original context.''
		\item ``This course will teach you how to refactor any codebase with confidence, rather than poking at the edges of its functionality in fear.''
		\item ``Release costs'' serve as an indicator to the existence of ``a Big Ball of Mud.''
		\item ``Factors that inhibit testing'': \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item ``Coupling, coupling, coupling''
			\item ``The inconstant environment''
			\item ``Trust''
			\item ``Defensive code''
			\item ``Fuzzy (or no!) abstraction borders''
			\end{enumerate}
		\item ``Key characteristics'' identified in situ: ``diagnostics, contracts, code coverage, and testing.''
		\item Remember the following ``when testing mud-balls'': ``automation; minimalism, incrementality, unit testing vs component testing; coverage (in realistic time); only change what you can test (and are testing!) -- [there are] exceptions to this rule; beyond salvation -- sometimes it's just mud.''
		\item Islands of ``known Functionality'' are created as follows: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item ``Decomposition -- Identifying Units, Identifying Components, and Identifying Modules''
			\item ``Triage''
			\item ``Isolation''
			\item ``Striding two worlds''
			\item ``Transplantation''
			\item ``Separation''
			\item ``Versioning -- Static and Dynamic''
			\item ``When to `throw it out'.''
			\end{enumerate}
		\item ``Inconstant Environment'' handling: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item ``File system''
			\item ``Memory''
			\item ``User-interface''
			\item ``Time''
			\item ``Data storage''
			\end{enumerate}
		\item Techniques to address/mitigate coupling: \vspace{-0.1cm}
			\begin{enumerate} \itemsep -1pt
			\item ``Pre-processor'': \vspace{-0.1cm}
				\begin{itemize} \itemsep -1pt
				\item \#ifdef
				\item \#define
				\item \#include
				\end{itemize}
			\item ``linkage'': \vspace{-0.1cm}
				\begin{itemize} \itemsep -1pt
				\item ``interpositioning''
				\item ``dynamic library redirection''
				\end{itemize}
			\item ``object-oriented techniques'': \vspace{-0.1cm}
				\begin{itemize} \itemsep -1pt
				\item ``overloading''
				\item ``overriding''
				\item ``inheritance''
				\item ``interfaces''
				\end{itemize}
			\item ``patterns'': \vspace{-0.1cm}
				\begin{itemize} \itemsep -1pt
				\item ``class adaptor''
				\item ``instance adaptor''
				\item ``decorator''
				\item ``visitor''
				\end{itemize}
			\item ``generic programming'': \vspace{-0.1cm}
				\begin{itemize} \itemsep -1pt
				\item ``policies''
				\item ``shims''
				\item ``traits''
				\end{itemize}
			\item ``Testing'': \vspace{-0.1cm}
				\begin{itemize} \itemsep -1pt
				\item ``Stubbing''
				\item ``Mocking''
				\item ``Versioned testing''
				\end{itemize}
			\end{enumerate}
		\item 
		\item 
		\item 
		\item 
		\item 
		\item 
		\item 
		\item 
		\end{enumerate}
	\end{enumerate}
\end{enumerate}




















